// src/sh4_codegen.c
// SH4 Code Generation for Sega Dreamcast
// Hitachi SH-4 32-bit RISC processor @ 200 MHz

#include "sh4_codegen.h"
#include "sh4_instruction_set.h"
#include "sh4_register_allocator.h"
#include "ast.h"
#include "error.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Initialize SH4 code generator
void sh4_codegen_init(SH4CodeGen* gen, FILE* output) {
    if (!gen || !output) {
        return;
    }

    gen->output = output;
    gen->label_counter = 0;
    gen->stack_offset = 0;
    gen->in_function = 0;

    // Initialize register allocator
    sh4_regalloc_init(&gen->regalloc);
}

// Generate SH4 assembly header
void sh4_emit_header(SH4CodeGen* gen) {
    fprintf(gen->output, "! Sega Dreamcast SH4 Assembly\n");
    fprintf(gen->output, "! Generated by KCC Compiler\n");
    fprintf(gen->output, "! Target: Hitachi SH-4 @ 200 MHz\n");
    fprintf(gen->output, "! Byte Order: Little Endian\n");
    fprintf(gen->output, "! FPU: Single-precision hardware FPU\n");
    fprintf(gen->output, "\n");
    fprintf(gen->output, "\t.section .text\n");
    fprintf(gen->output, "\t.align 4\n");
    fprintf(gen->output, "\n");
}

// Generate SH4 function prologue
void sh4_emit_function_prologue(SH4CodeGen* gen, const char* func_name) {
    fprintf(gen->output, "\t.global _%s\n", func_name);
    fprintf(gen->output, "_%s:\n", func_name);
    fprintf(gen->output, "\tmov.l\tr14, @-r15\n");  // Save frame pointer
    fprintf(gen->output, "\tsts.l\tpr, @-r15\n");   // Save return address
    fprintf(gen->output, "\tmov\tr15, r14\n");      // Setup frame pointer

    gen->in_function = 1;
}

// Generate SH4 function epilogue
void sh4_emit_function_epilogue(SH4CodeGen* gen) {
    fprintf(gen->output, "\tmov\tr14, r15\n");      // Restore stack pointer
    fprintf(gen->output, "\tlds.l\t@r15+, pr\n");   // Restore return address
    fprintf(gen->output, "\tmov.l\t@r15+, r14\n");  // Restore frame pointer
    fprintf(gen->output, "\trts\n");                // Return
    fprintf(gen->output, "\tnop\n");                // Delay slot
    fprintf(gen->output, "\n");

    gen->in_function = 0;
}

// Generate SH4 move instruction
void sh4_emit_mov(SH4CodeGen* gen, int dest_reg, int src_reg) {
    fprintf(gen->output, "\tmov\tr%d, r%d\n", src_reg, dest_reg);
}

// Generate SH4 load immediate
void sh4_emit_movi(SH4CodeGen* gen, int dest_reg, int immediate) {
    if (immediate >= -128 && immediate <= 127) {
        fprintf(gen->output, "\tmov\t#%d, r%d\n", immediate, dest_reg);
    } else {
        // Use mov.l with PC-relative addressing for large immediates
        fprintf(gen->output, "\tmov.l\t.L%d, r%d\n", gen->label_counter, dest_reg);
        fprintf(gen->output, "\tbra\t.L%d_skip\n", gen->label_counter);
        fprintf(gen->output, "\tnop\n");
        fprintf(gen->output, ".L%d:\n", gen->label_counter);
        fprintf(gen->output, "\t.long\t%d\n", immediate);
        fprintf(gen->output, ".L%d_skip:\n", gen->label_counter);
        gen->label_counter++;
    }
}

// Generate SH4 add instruction
void sh4_emit_add(SH4CodeGen* gen, int dest_reg, int src_reg) {
    fprintf(gen->output, "\tadd\tr%d, r%d\n", src_reg, dest_reg);
}

// Generate SH4 subtract instruction
void sh4_emit_sub(SH4CodeGen* gen, int dest_reg, int src_reg) {
    fprintf(gen->output, "\tsub\tr%d, r%d\n", src_reg, dest_reg);
}

// Generate SH4 multiply instruction
void sh4_emit_mul(SH4CodeGen* gen, int dest_reg, int src_reg) {
    fprintf(gen->output, "\tmul.l\tr%d, r%d\n", src_reg, dest_reg);
    fprintf(gen->output, "\tsts\tmacl, r%d\n", dest_reg);
}

// Generate SH4 return statement
void sh4_emit_return(SH4CodeGen* gen, int value_reg) {
    if (value_reg != SH4_REG_R0) {
        sh4_emit_mov(gen, SH4_REG_R0, value_reg);
    }
    sh4_emit_function_epilogue(gen);
}

// Generate unique label
int sh4_new_label(SH4CodeGen* gen) {
    return gen->label_counter++;
}

// Emit label
void sh4_emit_label(SH4CodeGen* gen, int label_id) {
    fprintf(gen->output, ".L%d:\n", label_id);
}

// Generate SH4 code from AST
void sh4_generate_code(SH4CodeGen* gen, ASTNode* node) {
    if (!gen || !node) {
        return;
    }

    // TODO: Implement full AST traversal and code generation
    // This is a placeholder for the complete implementation
}

// Cleanup SH4 code generator
void sh4_codegen_cleanup(SH4CodeGen* gen) {
    if (!gen) {
        return;
    }

    sh4_regalloc_cleanup(&gen->regalloc);
}