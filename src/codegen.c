/**
* @file codegen.c
 * @brief Code generation module for KCC compiler
 * @author KCC Development Team
 * @version 1.10.0
 * @date 2024
 *
 * This module implements code generation for the KCC compiler, supporting
 * multiple target architectures (ARM64 and x86-64). It translates Abstract
 * Syntax Tree (AST) nodes into native assembly code for the target platform.
 *
 * @section codegen_architecture Architecture Support
 * - **ARM64** (Apple Silicon): Modern ARM 64-bit architecture
 * - **x86-64** (Intel/AMD): Traditional 64-bit x86 architecture
 *
 * The code generator automatically detects the target architecture at compile
 * time and generates appropriate assembly code using platform-specific
 * instructions, registers, and calling conventions.
 *
 * @section codegen_features Features
 * - Multi-architecture code generation
 * - Function call support with proper calling conventions
 * - Arithmetic and logical operations
 * - Control flow (if/else, loops)
 * - Variable storage and retrieval
 * - Label generation for jumps and branches
 *
 * @section codegen_example Usage Example
 * @code
 * // Create code generator
 * CodeGenerator *codegen = codegen_create("output.s");
 *
 * // Generate code from AST
 * if (codegen_generate(codegen, ast_root)) {
 *     printf("Code generation successful\n");
 * }
 *
 * // Clean up
 * codegen_destroy(codegen);
 * @endcode
 */

#include "kcc.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

// Detect architecture at compile time
#ifdef __aarch64__
#define TARGET_ARM64 1
#define TARGET_X86_64 0
#elif defined(__x86_64__)
#define TARGET_ARM64 0
#define TARGET_X86_64 1
#else
#error "Unsupported architecture"
#endif

CodeGenerator *codegen_create(const char *output_filename) {
    CodeGenerator *codegen = malloc(sizeof(CodeGenerator));
    if (!codegen) {
        error_fatal("Memory allocation failed for code generator");
        return NULL;
    }

    codegen->output_file = fopen(output_filename, "w");
    if (!codegen->output_file) {
        free(codegen);
        error_fatal("Could not open output file '%s'", output_filename);
        return NULL;
    }

    codegen->label_counter = 0;
    codegen->temp_counter = 0;

    return codegen;
}

void codegen_destroy(CodeGenerator *codegen) {
    if (codegen) {
        if (codegen->output_file) {
            fclose(codegen->output_file);
        }
        free(codegen);
    }
}

void codegen_emit(CodeGenerator *codegen, const char *format, ...) {
    va_list args;
    va_start(args, format);
    vfprintf(codegen->output_file, format, args);
    va_end(args);
    fprintf(codegen->output_file, "\n");
}

char *codegen_new_label(CodeGenerator *codegen) {
    char *label = malloc(32);
    if (!label) {
        error_fatal("Memory allocation failed for label");
        return NULL;
    }
    snprintf(label, 32, "L%d", codegen->label_counter++);
    return label;
}

char *codegen_new_temp(CodeGenerator *codegen) {
    char *temp = malloc(32);
    if (!temp) {
        error_fatal("Memory allocation failed for temp");
        return NULL;
    }
    snprintf(temp, 32, "t%d", codegen->temp_counter++);
    return temp;
}

bool codegen_generate(CodeGenerator *codegen, ASTNode *ast) {
    if (!codegen || !ast) {
        return false;
    }

    // Generate assembly header
#if TARGET_ARM64
    codegen_emit(codegen, "// Generated by KCC (ARM64/Apple Silicon) v%s", KCC_VERSION);
    codegen_emit(codegen, ".section __TEXT,__text,regular,pure_instructions");
    codegen_emit(codegen, ".build_version macos, 11, 0");
    codegen_emit(codegen, ".globl _main");
    codegen_emit(codegen, ".p2align 2");
#else
    codegen_emit(codegen, "# Generated by KCC (x86-64) v%s", KCC_VERSION);
    codegen_emit(codegen, ".section __TEXT,__text,regular,pure_instructions");
    codegen_emit(codegen, ".globl _main");
#endif
    codegen_emit(codegen, "");

    // Generate code for the program
    codegen_program(codegen, ast);

    // Generate main entry point
    codegen_emit(codegen, "");
    codegen_emit(codegen, "_main:");

#if TARGET_ARM64
    codegen_emit(codegen, "    stp     fp, lr, [sp, #-16]!");
    codegen_emit(codegen, "    mov     fp, sp");
    codegen_emit(codegen, "    bl      _main_func");
    codegen_emit(codegen, "    mov     w0, #0");
    codegen_emit(codegen, "    ldp     fp, lr, [sp], #16");
    codegen_emit(codegen, "    ret");
#else
    codegen_emit(codegen, "    pushq   %%rbp");
    codegen_emit(codegen, "    movq    %%rsp, %%rbp");
    codegen_emit(codegen, "    callq   _main_func");
    codegen_emit(codegen, "    movq    $0x2000001, %%rax");
    codegen_emit(codegen, "    movq    $0, %%rdi");
    codegen_emit(codegen, "    syscall");
    codegen_emit(codegen, "    popq    %%rbp");
    codegen_emit(codegen, "    retq");
#endif

    return true;
}

void codegen_program(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_PROGRAM) return;

    for (int i = 0; i < node->data.program.declaration_count; i++) {
        ASTNode *decl = node->data.program.declarations[i];

        if (decl->type == AST_FUNCTION_DECLARATION) {
            codegen_function_declaration(codegen, decl);
        } else if (decl->type == AST_VARIABLE_DECLARATION) {
            codegen_variable_declaration(codegen, decl);
        }
    }
}

void codegen_function_declaration(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_FUNCTION_DECLARATION) return;

    codegen_emit(codegen, "");
#if TARGET_ARM64
    codegen_emit(codegen, "// Function: %s", node->data.function_decl.name);
#else
    codegen_emit(codegen, "# Function: %s", node->data.function_decl.name);
#endif

    if (strcmp(node->data.function_decl.name, "main") == 0) {
        codegen_emit(codegen, "_main_func:");
    } else {
        codegen_emit(codegen, "_%s:", node->data.function_decl.name);
    }

    // Function prologue
#if TARGET_ARM64
    codegen_emit(codegen, "    stp     fp, lr, [sp, #-16]!");
    codegen_emit(codegen, "    mov     fp, sp");
#else
    codegen_emit(codegen, "    pushq   %%rbp");
    codegen_emit(codegen, "    movq    %%rsp, %%rbp");
#endif

    if (node->data.function_decl.body) {
        codegen_compound_statement(codegen, node->data.function_decl.body);
    }

    // Function epilogue - default return 0
#if TARGET_ARM64
    codegen_emit(codegen, "    mov     w0, #0");
    codegen_emit(codegen, "    ldp     fp, lr, [sp], #16");
    codegen_emit(codegen, "    ret");
#else
    codegen_emit(codegen, "    movq    $0, %%rax");
    codegen_emit(codegen, "    movq    %%rbp, %%rsp");
    codegen_emit(codegen, "    popq    %%rbp");
    codegen_emit(codegen, "    retq");
#endif
}

void codegen_variable_declaration(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_VARIABLE_DECLARATION) return;

#if TARGET_ARM64
    codegen_emit(codegen, "// Variable: %s", node->data.var_decl.name);
#else
    codegen_emit(codegen, "# Variable: %s", node->data.var_decl.name);
#endif

    if (node->data.var_decl.initializer) {
        codegen_expression(codegen, node->data.var_decl.initializer);
#if TARGET_ARM64
        codegen_emit(codegen, "    // Store result in %s", node->data.var_decl.name);
#else
        codegen_emit(codegen, "    # Store result in %s", node->data.var_decl.name);
#endif
    }
}

void codegen_statement(CodeGenerator *codegen, ASTNode *node) {
    switch (node->type) {
        case AST_COMPOUND_STATEMENT:
            codegen_compound_statement(codegen, node);
            break;
        case AST_EXPRESSION_STATEMENT:
            codegen_expression_statement(codegen, node);
            break;
        case AST_RETURN_STATEMENT:
            codegen_return_statement(codegen, node);
            break;
        case AST_IF_STATEMENT:
            codegen_if_statement(codegen, node);
            break;
        case AST_WHILE_STATEMENT:
            codegen_while_statement(codegen, node);
            break;
        case AST_FOR_STATEMENT:
            codegen_for_statement(codegen, node);
            break;
        case AST_VARIABLE_DECLARATION:
            codegen_variable_declaration(codegen, node);
            break;
        default:
#if TARGET_ARM64
            codegen_emit(codegen, "    // Unsupported statement type: %s",
                        ast_node_type_to_string(node->type));
#else
            codegen_emit(codegen, "    # Unsupported statement type: %s",
                        ast_node_type_to_string(node->type));
#endif
            break;
    }
}

void codegen_compound_statement(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_COMPOUND_STATEMENT) return;

    for (int i = 0; i < node->data.compound_stmt.statement_count; i++) {
        codegen_statement(codegen, node->data.compound_stmt.statements[i]);
    }
}

void codegen_expression_statement(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_EXPRESSION_STATEMENT) return;

    if (node->data.expression_stmt.expression) {
        codegen_expression(codegen, node->data.expression_stmt.expression);
    }
}

void codegen_return_statement(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_RETURN_STATEMENT) return;

    if (node->data.return_stmt.expression) {
        codegen_expression(codegen, node->data.return_stmt.expression);
#if TARGET_ARM64
        codegen_emit(codegen, "    // Result already in w0/x0");
#else
        codegen_emit(codegen, "    # Result already in %%rax");
#endif
    } else {
#if TARGET_ARM64
        codegen_emit(codegen, "    mov     w0, #0");
#else
        codegen_emit(codegen, "    movq    $0, %%rax");
#endif
    }

#if TARGET_ARM64
    codegen_emit(codegen, "    ldp     fp, lr, [sp], #16");
    codegen_emit(codegen, "    ret");
#else
    codegen_emit(codegen, "    movq    %%rbp, %%rsp");
    codegen_emit(codegen, "    popq    %%rbp");
    codegen_emit(codegen, "    retq");
#endif
}

void codegen_if_statement(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_IF_STATEMENT) return;

    char *else_label = codegen_new_label(codegen);
    char *end_label = codegen_new_label(codegen);

    codegen_expression(codegen, node->data.if_stmt.condition);
#if TARGET_ARM64
    codegen_emit(codegen, "    cmp     w0, #0");
    codegen_emit(codegen, "    b.eq    %s", else_label);
#else
    codegen_emit(codegen, "    testq   %%rax, %%rax");
    codegen_emit(codegen, "    jz      %s", else_label);
#endif

    codegen_statement(codegen, node->data.if_stmt.then_stmt);
#if TARGET_ARM64
    codegen_emit(codegen, "    b       %s", end_label);
#else
    codegen_emit(codegen, "    jmp     %s", end_label);
#endif

    codegen_emit(codegen, "%s:", else_label);
    if (node->data.if_stmt.else_stmt) {
        codegen_statement(codegen, node->data.if_stmt.else_stmt);
    }

    codegen_emit(codegen, "%s:", end_label);

    free(else_label);
    free(end_label);
}

void codegen_while_statement(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_WHILE_STATEMENT) return;

    char *loop_label = codegen_new_label(codegen);
    char *end_label = codegen_new_label(codegen);

    codegen_emit(codegen, "%s:", loop_label);

    codegen_expression(codegen, node->data.while_stmt.condition);
#if TARGET_ARM64
    codegen_emit(codegen, "    cmp     w0, #0");
    codegen_emit(codegen, "    b.eq    %s", end_label);
#else
    codegen_emit(codegen, "    testq   %%rax, %%rax");
    codegen_emit(codegen, "    jz      %s", end_label);
#endif

    codegen_statement(codegen, node->data.while_stmt.body);
#if TARGET_ARM64
    codegen_emit(codegen, "    b       %s", loop_label);
#else
    codegen_emit(codegen, "    jmp     %s", loop_label);
#endif

    codegen_emit(codegen, "%s:", end_label);

    free(loop_label);
    free(end_label);
}

void codegen_for_statement(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_FOR_STATEMENT) return;

    char *loop_label = codegen_new_label(codegen);
    char *update_label = codegen_new_label(codegen);
    char *end_label = codegen_new_label(codegen);

    if (node->data.for_stmt.init) {
        codegen_expression(codegen, node->data.for_stmt.init);
    }

    codegen_emit(codegen, "%s:", loop_label);

    if (node->data.for_stmt.condition) {
        codegen_expression(codegen, node->data.for_stmt.condition);
#if TARGET_ARM64
        codegen_emit(codegen, "    cmp     w0, #0");
        codegen_emit(codegen, "    b.eq    %s", end_label);
#else
        codegen_emit(codegen, "    testq   %%rax, %%rax");
        codegen_emit(codegen, "    jz      %s", end_label);
#endif
    }

    codegen_statement(codegen, node->data.for_stmt.body);

    codegen_emit(codegen, "%s:", update_label);
    if (node->data.for_stmt.update) {
        codegen_expression(codegen, node->data.for_stmt.update);
    }
#if TARGET_ARM64
    codegen_emit(codegen, "    b       %s", loop_label);
#else
    codegen_emit(codegen, "    jmp     %s", loop_label);
#endif

    codegen_emit(codegen, "%s:", end_label);

    free(loop_label);
    free(update_label);
    free(end_label);
}

void codegen_expression(CodeGenerator *codegen, ASTNode *node) {
    switch (node->type) {
        case AST_BINARY_OP:
            codegen_binary_expression(codegen, node);
            break;
        case AST_UNARY_OP:
            codegen_unary_expression(codegen, node);
            break;
        case AST_FUNCTION_CALL:
            codegen_call_expression(codegen, node);
            break;
        case AST_IDENTIFIER:
            codegen_identifier(codegen, node);
            break;
        case AST_NUMBER_LITERAL:
            codegen_number(codegen, node);
            break;
        case AST_STRING_LITERAL:
            codegen_string(codegen, node);
            break;
        case AST_ASSIGNMENT:
            codegen_assignment(codegen, node);
            break;
        default:
#if TARGET_ARM64
            codegen_emit(codegen, "    // Unsupported expression type: %s",
                        ast_node_type_to_string(node->type));
#else
            codegen_emit(codegen, "    # Unsupported expression type: %s",
                        ast_node_type_to_string(node->type));
#endif
            break;
    }
}

void codegen_binary_expression(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_BINARY_OP) return;

    codegen_expression(codegen, node->data.binary_expr.left);
#if TARGET_ARM64
    codegen_emit(codegen, "    str     w0, [sp, #-16]!");
#else
    codegen_emit(codegen, "    pushq   %%rax");
#endif

    codegen_expression(codegen, node->data.binary_expr.right);
#if TARGET_ARM64
    codegen_emit(codegen, "    mov     w1, w0");
    codegen_emit(codegen, "    ldr     w0, [sp], #16");
#else
    codegen_emit(codegen, "    movq    %%rax, %%rbx");
    codegen_emit(codegen, "    popq    %%rax");
#endif

    switch (node->data.binary_expr.operator) {
        case TOKEN_PLUS:
#if TARGET_ARM64
            codegen_emit(codegen, "    add     w0, w0, w1");
#else
            codegen_emit(codegen, "    addq    %%rbx, %%rax");
#endif
            break;
        case TOKEN_MINUS:
#if TARGET_ARM64
            codegen_emit(codegen, "    sub     w0, w0, w1");
#else
            codegen_emit(codegen, "    subq    %%rbx, %%rax");
#endif
            break;
        case TOKEN_MULTIPLY:
#if TARGET_ARM64
            codegen_emit(codegen, "    mul     w0, w0, w1");
#else
            codegen_emit(codegen, "    imulq   %%rbx, %%rax");
#endif
            break;
        case TOKEN_GREATER:
#if TARGET_ARM64
            codegen_emit(codegen, "    cmp     w0, w1");
            codegen_emit(codegen, "    cset    w0, gt");
#else
            codegen_emit(codegen, "    cmpq    %%rbx, %%rax");
            codegen_emit(codegen, "    setg    %%al");
            codegen_emit(codegen, "    movzbq  %%al, %%rax");
#endif
            break;
        default:
#if TARGET_ARM64
            codegen_emit(codegen, "    // Unsupported binary operator: %s",
                        token_type_to_string(node->data.binary_expr.operator));
#else
            codegen_emit(codegen, "    # Unsupported binary operator: %s",
                        token_type_to_string(node->data.binary_expr.operator));
#endif
            break;
    }
}

void codegen_unary_expression(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_UNARY_OP) return;

    codegen_expression(codegen, node->data.unary_expr.operand);

    switch (node->data.unary_expr.operator) {
        case TOKEN_MINUS:
#if TARGET_ARM64
            codegen_emit(codegen, "    neg     w0, w0");
#else
            codegen_emit(codegen, "    negq    %%rax");
#endif
            break;
        case TOKEN_NOT:
#if TARGET_ARM64
            codegen_emit(codegen, "    cmp     w0, #0");
            codegen_emit(codegen, "    cset    w0, eq");
#else
            codegen_emit(codegen, "    testq   %%rax, %%rax");
            codegen_emit(codegen, "    setz    %%al");
            codegen_emit(codegen, "    movzbq  %%al, %%rax");
#endif
            break;
        default:
#if TARGET_ARM64
            codegen_emit(codegen, "    // Unsupported unary operator: %s",
                        token_type_to_string(node->data.unary_expr.operator));
#else
            codegen_emit(codegen, "    # Unsupported unary operator: %s",
                        token_type_to_string(node->data.unary_expr.operator));
#endif
            break;
    }
}

void codegen_call_expression(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_FUNCTION_CALL) return;

#if TARGET_ARM64
    // ARM64 calling convention uses x0-x7 for first 8 args
    for (int i = 0; i < node->data.call_expr.argument_count && i < 8; i++) {
        codegen_expression(codegen, node->data.call_expr.arguments[i]);
        if (i > 0) {
            codegen_emit(codegen, "    mov     x%d, x0", i);
        }
    }
    codegen_emit(codegen, "    bl      _%s", node->data.call_expr.function_name);
#else
    // x86-64 - push args right to left
    for (int i = node->data.call_expr.argument_count - 1; i >= 0; i--) {
        codegen_expression(codegen, node->data.call_expr.arguments[i]);
        codegen_emit(codegen, "    pushq   %%rax");
    }
    codegen_emit(codegen, "    callq   _%s", node->data.call_expr.function_name);
    if (node->data.call_expr.argument_count > 0) {
        codegen_emit(codegen, "    addq    $%d, %%rsp",
                    node->data.call_expr.argument_count * 8);
    }
#endif
}

void codegen_identifier(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_IDENTIFIER) return;

#if TARGET_ARM64
    codegen_emit(codegen, "    // Load variable %s", node->data.identifier.name);
    codegen_emit(codegen, "    ldr     w0, [fp, #-8]");
#else
    codegen_emit(codegen, "    # Load variable %s", node->data.identifier.name);
    codegen_emit(codegen, "    movq    -8(%%rbp), %%rax");
#endif
}

void codegen_number(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_NUMBER_LITERAL) return;

#if TARGET_ARM64
    codegen_emit(codegen, "    mov     w0, #%d", node->data.number.value);
#else
    codegen_emit(codegen, "    movq    $%d, %%rax", node->data.number.value);
#endif
}

void codegen_string(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_STRING_LITERAL) return;

#if TARGET_ARM64
    codegen_emit(codegen, "    // String literal: \"%s\"", node->data.string.value);
    codegen_emit(codegen, "    adrp    x0, string_literal_%d@PAGE", codegen->label_counter);
    codegen_emit(codegen, "    add     x0, x0, string_literal_%d@PAGEOFF", codegen->label_counter++);
#else
    codegen_emit(codegen, "    # String literal: \"%s\"", node->data.string.value);
    codegen_emit(codegen, "    movq    $string_literal_%d, %%rax", codegen->label_counter++);
#endif
}

void codegen_assignment(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_ASSIGNMENT) return;

    codegen_expression(codegen, node->data.assignment.value);

#if TARGET_ARM64
    codegen_emit(codegen, "    // Assign to %s", node->data.assignment.variable);
    codegen_emit(codegen, "    str     w0, [fp, #-8]");
#else
    codegen_emit(codegen, "    # Assign to %s", node->data.assignment.variable);
    codegen_emit(codegen, "    movq    %%rax, -8(%%rbp)");
#endif
}